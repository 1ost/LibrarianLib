buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        maven { url = 'http://repo.spongepowered.org/maven' }
        jcenter()
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.61"
        classpath 'org.spongepowered:mixingradle:0.7-SNAPSHOT'
        // rolled back from 4.0.4 to 4.0.1 due to #425: https://github.com/johnrengelman/shadow/issues/425
        classpath 'com.github.jengelman.gradle.plugins:shadow:4.0.1'
    }
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'org.spongepowered.mixin'
apply plugin: 'com.github.johnrengelman.shadow'

import com.github.jengelman.gradle.plugins.shadow.ShadowStats
import com.github.jengelman.gradle.plugins.shadow.relocation.RelocatePathContext
import com.github.jengelman.gradle.plugins.shadow.relocation.Relocator
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

ext.modid = project.name == "core" ? "librarianlib" : "librarianlib-${project.name}".toString()
ext.modid_test = "$modid-test".toString()

// Need this here so eclipse task generates correctly.
sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8'
version = rootProject.mod_version
group = "com.teamwizardry.librarianlib"
archivesBaseName = modid

configurations {
    api.extendsFrom(shade)
    testApi.extendsFrom(shade)
    api.extendsFrom(mod)
    testApi.extendsFrom(mod)
}

minecraft {
    mappings channel: mc_mappings_channel, version: mc_mappings_version
}

dependencies {
    minecraft "net.minecraftforge:forge:$mc_version-$forge_version"
    implementation("org.spongepowered:mixin:0.8-SNAPSHOT")

    // Add kotlin dependencies manually to the modules, but don't include them at runtime, since Kottle doesn't include
    // kotlin sources
    compileOnly "org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.3.61"
    compileOnly "org.jetbrains.kotlin:kotlin-reflect:1.3.61"
    compileOnly "org.jetbrains:annotations:18.0.0"
    compileOnly "org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.3.2"

    testCompileOnly "org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.3.61"
    testCompileOnly "org.jetbrains.kotlin:kotlin-reflect:1.3.61"
    testCompileOnly "org.jetbrains:annotations:18.0.0"
    testCompileOnly "org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.3.2"

    // include Kottle _after_ all of the kotlin libraries, so IntelliJ IDEA uses the direct dependencies first
    //files("/Users/code/Documents/mods/kottle/build/libs/Kottle-1.5.0.jar")//
    mod "kottle:Kottle:$kottle_version"

    compileOnly "kottle:Kottle:$kottle_version"
    testCompileOnly "kottle:Kottle:$kottle_version"
}

mixin {
}

tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
        jvmTarget = "1.8"
        freeCompilerArgs += [
                "-Xjvm-default=enable",
                "-Xuse-experimental=kotlin.Experimental",
                "-Xuse-experimental=kotlin.ExperimentalUnsignedTypes"
        ]
    }
}

// exclude "master" files from output
def masterPatterns = [
        "**/*.psd",
        "**/*.xcf",
        "**/*.kra",
        "**/*.blend",
        "**/_master/**"
]

processResources {
    masterPatterns.each {
        exclude it
    }
}
processTestResources {
    masterPatterns.each {
        exclude it
    }
}

// =====================================================================================================================
//region // Build setup

sourceSets {
    main.ext.refMap = "${project.name}.refmap.json"
    test.ext.refMap = "${project.name}-test.refmap.json"
}

// ---------------------------------------------------------------------------------------------------------------------
//region // File generation

static String tomlDependency(String modid, String dependencyid, String version, String ordering) {
    return """\
       |[[dependencies.$modid]]
       |    modId="$dependencyid"
       |    versionRange="$version"
       |    mandatory=true
       |    ordering="$ordering"
       |""".stripMargin()
}

// Generated files:
// - MixinConnector.java
//   - generated by merging all the `META-INF/mixins.txt` files
// - SkeletonMod.java
//   - generated based on the mod ID
// - META-INF/mods.toml
//   - generated by appending the `META-INF/dependencies.toml` files to a skeleton `mods.toml` file
// - pack.mcmeta
task generateFiles {
    ext.genJava = "$buildDir/generated/main/java"
    ext.genResources = "$buildDir/generated/main/resources"
    ext.resourcesDir = "$rootDir/src/main/resources"

    ext.mixinsTxt = file("$resourcesDir/META-INF/mixins.txt")
    ext.dependenciesToml = file("$resourcesDir/META-INF/dependencies.toml")
    ext.manifest = file("$resourcesDir/META-INF/MANIFEST.MF")

    inputs.files(
            mixinsTxt,
            dependenciesToml,
            manifest
    )

    ext.mixinConnectorOut = file("$genJava/MixinConnector.java")
    ext.skeletonModOut = file("$genJava/SkeletonMod.java")
    ext.modsTomlOut = file("$genResources/META-INF/mods.toml")
    ext.manifestOut = file("$genResources/META-INF/MANIFEST.MF")
    ext.packMcmetaOut = file("$genResources/pack.mcmeta")
    outputs.files(
            mixinConnectorOut,
            skeletonModOut,
            modsTomlOut,
            manifestOut
    )
    if(project.name != "core")
        outputs.files(packMcmetaOut)

    doLast {
        modsTomlOut.parentFile.mkdirs()

        skeletonModOut.text = """\
               |import net.minecraftforge.fml.common.Mod;

               |@Mod("$modid")
               |public class SkeletonMod {}
            |""".stripMargin()

        def mixinConfigs = mixinsTxt.exists() ? mixinsTxt.readLines() : []
        mixinConnectorOut.text = """\
               |import org.spongepowered.asm.mixin.Mixins;
               |import org.spongepowered.asm.mixin.connect.IMixinConnector;

               |public class MixinConnector implements IMixinConnector {
               |    @Override
               |    public void connect() {
               |        ${mixinConfigs.collect { "Mixins.addConfiguration(\"$it\");" }.join("\n|        ")}
               |    }
               |}
            |""".stripMargin()

        manifestOut.text = (manifest.exists() ? manifest.text : "") + "MixinConnector: MixinConnector\n"

        if(project.name != "core")
            packMcmetaOut.text = """\
                   |{
                   |    "pack": {
                   |        "description": "LibrarianLib $human_name resources",
                   |        "pack_format": 4
                   |    }
                   |}
                |""".stripMargin()

        def tomlString = """\
               |modLoader="kotlinfml"
               |loaderVersion="[1,)"
               |[[mods]]
               |modId="$modid"
               |version="${rootProject.mod_version}"
               |displayName="LibrarianLib $human_name"
               |description="$description"
        |""".stripMargin()
        if(dependenciesToml.exists())
            tomlString += dependenciesToml.text.replaceAll("MOD_ID", modid).replaceAll("\\s+\$", "")
        if(project.name != "core")
            tomlString += tomlDependency(modid, "librarianlib", "[${rootProject.mod_version}]", "BEFORE")
        modsTomlOut.text = tomlString
    }
}
sourceSets.main.java.srcDirs(generateFiles.genJava)
sourceSets.main.resources.srcDirs(generateFiles.genResources)
compileJava.dependsOn(generateFiles)
compileKotlin.dependsOn(generateFiles)

// Generated test files:
// - MixinConnector.java
//   - generated by merging all the `META-INF/mixins.txt` files
// - SkeletonMod.java
//   - generated based on the mod ID
// - META-INF/mods.toml
//   - generated by appending the `META-INF/dependencies.toml` files to a skeleton `mods.toml` file
// - pack.mcmeta
task generateTestFiles {
    ext.genJava = "$buildDir/generated/test/java"
    ext.genResources = "$buildDir/generated/test/resources"
    ext.resourcesDir = "$rootDir/src/test/resources"

    ext.mixinsTxt = file("$resourcesDir/META-INF/mixins.txt")
    ext.dependenciesToml = file("$resourcesDir/META-INF/dependencies.toml")
    ext.manifest = file("$resourcesDir/META-INF/MANIFEST.MF")

    inputs.files(
            mixinsTxt,
            dependenciesToml,
            manifest
    )

    ext.mixinConnectorOut = file("$genJava/MixinConnector.java")
//    ext.skeletonModOut = file("$genJava/SkeletonMod.java")
    ext.modsTomlOut = file("$genResources/META-INF/mods.toml")
    ext.manifestOut = file("$genResources/META-INF/MANIFEST.MF")
    ext.packMcmetaOut = file("$genResources/pack.mcmeta")
    outputs.files(
            mixinConnectorOut,
//            skeletonModOut,
            modsTomlOut,
            manifestOut,
            packMcmetaOut
    )

    doLast {
        modsTomlOut.parentFile.mkdirs()

//        skeletonModOut.text = """\
//               |import net.minecraftforge.fml.common.Mod;
//
//               |@Mod("$modid_test")
//               |public class SkeletonMod {}
//            |""".stripMargin()

        def mixinConfigs = mixinsTxt.exists() ? mixinsTxt.readLines() : []
        mixinConnectorOut.text = """\
               |import org.spongepowered.asm.mixin.Mixins;
               |import org.spongepowered.asm.mixin.connect.IMixinConnector;

               |public class MixinConnector implements IMixinConnector {
               |    @Override
               |    public void connect() {
               |        ${mixinConfigs.collect { "Mixins.addConfiguration(\"$it\");" }.join("\n|        ")}
               |    }
               |}
            |""".stripMargin()

        manifestOut.text = (manifest.exists() ? manifest.text : "") + "MixinConnector: MixinConnector\n"

        packMcmetaOut.text = """\
               |{
               |    "pack": {
               |        "description": "LibrarianLib $human_name resources",
               |        "pack_format": 4
               |    }
               |}
            |""".stripMargin()

        def tomlString = """\
               |modLoader="kotlinfml"
               |loaderVersion="[1,)"
               |[[mods]]
               |modId="$modid_test"
               |version="${rootProject.mod_version}"
               |displayName="LibrarianLib $human_name Test"
               |description="Tests for the $human_name module"
        |""".stripMargin()
        if(dependenciesToml.exists())
            tomlString += dependenciesToml.text.replaceAll("MOD_ID", modid_test).replaceAll("\\s+\$", "")
        tomlString += tomlDependency(modid_test, "librarianlib", "[${rootProject.mod_version}]", "BEFORE")
        modsTomlOut.text = tomlString
    }
}
sourceSets.test.java.srcDirs(generateTestFiles.genJava)
sourceSets.test.resources.srcDirs(generateTestFiles.genResources)
compileTestJava.dependsOn(generateTestFiles)
compileTestKotlin.dependsOn(generateTestFiles)

//endregion
// ---------------------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------------------
//region // Shading

ext.shadePackages = { String... packages ->
    rootProject.shadePackages.addAll(packages)
}

def shadeOutput = file("$buildDir/shade/main")
// Gross, but ForgeGradle forces my hand by directly using `getResourcesDir()` and `getClassesDirs()` instead of
// using `getOutput()`, meaning I can't just do `output.dir(shadeOutput, builtBy: 'copyShadeClasses')`. I could
// use a separate sourceSet, however that comes with the baggage of a bunch of tasks, configurations, and source
// directories (which an IDE may conveniently create for you automatically)
// https://github.com/MinecraftForge/ForgeGradle/blob/ccf3035ba1f435f0f1a685a70d85df5481ee8b73/src/common/java/net/minecraftforge/gradle/common/util/runs/RunConfigGenerator.java#L128
// https://github.com/MinecraftForge/ForgeGradle/blob/ccf3035ba1f435f0f1a685a70d85df5481ee8b73/src/common/java/net/minecraftforge/gradle/common/util/runs/RunConfigGenerator.java#L138
((ConfigurableFileCollection)sourceSets.main.output.classesDirs).from(shadeOutput)

afterEvaluate {
    task copyShadeClasses(type: Sync) {
        into shadeOutput
        from configurations.shade.collect { zipTree(it) }
        exclude 'META-INF', 'META-INF/**'
    }
    compileJava.finalizedBy(copyShadeClasses)
}
//endregion
// ---------------------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------------------
//region // Jars

jar {
    classifier = 'obf'
    manifest.attributes(
            "Implementation-Title": "LibrarianLib $human_name",
            "Implementation-Version": "$mod_version",
            "Implementation-Vendor": "Team Wizardry",
            "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            // Specify the IMixinConnector. This contains only the mixin files from this specific module.
            // https://github.com/SpongePowered/Mixin/wiki/Release-Notes---Mixin-0.8#toolchain-and-environment-changes
            "MixinConnector": "MixinConnector"
    )
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    includeEmptyDirs = false
    manifest.from(jar.manifest)
    from sourceSets.main.allSource
    from sourceSets.main.output.resourcesDir
    dependsOn processResources
    exclude '**/*.class'
}

task deobfJar(type: ShadowJar) {
    configurations = []
    classifier = ''
    includeEmptyDirs = false
    manifest.from(jar.manifest)

    from sourceSets.main.output
    dependsOn classes
    dependsOn processResources

    afterEvaluate {
        // add relocation rules after all the projects have added their packages to the list
        rootProject.shadePackages.each {
            relocate it, "ll.$it"
        }
    }
}

// create a sources jar that includes this module and the shaded dependencies
// Based largely on the gradle-preshadow-plugin: https://github.com/Abnaxos/gradle-preshadow-plugin/blob/07580f93f38818b15c411f6c47abea8cdfd0b2f9/src/main/groovy/ch/raffael/gradlePlugins/preshadow/Preshadow.groovy
// has to be run in afterEvaluate since the relocator package list isn't ready until all the modules are configured
afterEvaluate {
    sourcesJar {
        // collect the sources for all the shade dependencies
        from configurations.detachedConfiguration(
                configurations.shade.allDependencies.collect({ dep ->
                    def sourceDep = dependencies.create(group: dep.group,
                            name: dep.name,
                            classifier: 'sources',
                            version: dep.version)
                    // apply any exclusions from the main dependency to the sources dependency
                    if (dep instanceof ModuleDependency && sourceDep instanceof ModuleDependency) {
                        def originalModule = (ModuleDependency) dep
                        def sourceModule = (ModuleDependency) sourceDep

                        originalModule.excludeRules.each {
                            sourceModule.exclude group: it.group, module: it.module
                        }
                    }
                    return sourceDep
                }) as Dependency[]).collect { f ->
            f.directory ? fileTree(f) : zipTree(f)
        }
        def stats = new ShadowStats()
        // remap sources
        eachFile { FileCopyDetails copyDetails ->
            deobfJar.relocators.each { Relocator reloc ->
                def pathContext = new RelocatePathContext(copyDetails.sourcePath, stats)
                if (reloc.canRelocatePath(pathContext)) {
                    copyDetails.path = reloc.relocatePath(pathContext)
                }
                if (!copyDetails.directory)
                    copyDetails.filter { String line ->
                        reloc.applyToSourceContent(line)
                    }
            }
        }
    }
}

//endregion
// ---------------------------------------------------------------------------------------------------------------------

//endregion
// =====================================================================================================================
