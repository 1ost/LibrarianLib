buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        maven { url = 'http://repo.spongepowered.org/maven' }
        jcenter()
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.61"
        classpath 'org.spongepowered:mixingradle:0.7-SNAPSHOT'
    }
}

allprojects {
    apply plugin: 'net.minecraftforge.gradle'
    apply plugin: 'org.spongepowered.mixin'
    apply plugin: 'eclipse'
    apply plugin: 'idea'
    apply plugin: 'kotlin'
    apply plugin: 'java-library'

    ext.allmodules = rootProject.subprojects.findAll { it.path != ":runtime" }
    ext.modid = (project == rootProject || project.name == "core") ? "librarianlib" : "librarianlib-${project.name}"
    ext.modid_test = "librarianlib-${project.name}-test"

    version = rootProject.mod_version
    group = "com.teamwizardry.librarianlib"
    archivesBaseName = modid

    sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

    // unfortunately, due to the interdependence of the modules, all the repositories used must be specified here. Any
    // repositories defined in the module `build.gradle` files won't be seen by any of the other modules
    repositories {
        jcenter()
        maven { url = "http://maven.shadowfacts.net/" }
        maven { url = "https://jitpack.io" }
        maven { url = "https://minecraft.curseforge.com/api/maven/" }
        maven { url = 'http://repo.spongepowered.org/maven' }
    }

    minecraft {
        mappings channel: mc_mappings_channel, version: mc_mappings_version
    }

    mixin {
        add sourceSets.main, "${project.name}.refmap.json"
        add sourceSets.test, "${project.name}-test.refmap.json"
    }

    // Create `lib___` configurations so those dependencies can be cherry-picked for inclusion in the runtime project
    // Also create a `shade` configuration to specify dependencies that should be shaded into the final jar
    configurations {
        shade
        api.extendsFrom(libApi)
        implementation.extendsFrom(libImplementation)
        testImplementation.extendsFrom(libTestImplementation)
        libRuntime.extendsFrom(libApi, libImplementation, libTestImplementation)
    }

    dependencies {
        minecraft "net.minecraftforge:forge:$mc_version-$forge_version"
        implementation("org.spongepowered:mixin:0.8-SNAPSHOT")
    }

    tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
        kotlinOptions {
            jvmTarget = "1.8"
            freeCompilerArgs += [
                "-Xjvm-default=enable",
                "-Xuse-experimental=kotlin.Experimental",
                "-Xuse-experimental=kotlin.ExperimentalUnsignedTypes"
            ]
        }
    }

    // exclude "master" files from output
    def masterPatterns = [
            "**/*.psd",
            "**/*.xcf",
            "**/*.kra",
            "**/*.blend",
            "**/_master/**"
    ]

    processResources {
        masterPatterns.each {
            exclude it
        }
    }
    processTestResources {
        masterPatterns.each {
            exclude it
        }
    }
}

// Properties defined in the `gradle.properties` file are accessible even before the project is evaluated.
ext.productionModules = allmodules.findAll { it.findProperty("development_only") != "true" }

// include the projects and shade their shade configurations
dependencies {
    productionModules.each {
        implementation(it)
        shade(project(path: it.path, configuration: "shade"))
    }
}

productionModules.each {
    classes.dependsOn(it.classes)
    processResources.dependsOn(it.processResources)
    jar.dependsOn(it.jar)
}

configure(allmodules) {
    // Add kotlin dependencies manually to the modules, but don't include them at runtime, since Kottle doesn't include
    // kotlin sources
    dependencies {
        compileOnly "org.jetbrains.kotlin:kotlin-stdlib:1.3.61"
        compileOnly "org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.3.61"
        compileOnly "org.jetbrains.kotlin:kotlin-reflect:1.3.61"
        compileOnly "org.jetbrains:annotations:18.0.0"
        compileOnly "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2"
        compileOnly "org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.3.2"
    }
}

// include Kottle _after_ all of the kotlin libraries, so IntelliJ IDEA uses the direct dependencies first
allprojects {
    dependencies {
        implementation "kottle:Kottle:$kottle_version"
    }
}

// liblib generates a few of the base files for the modules. The generators are a lot of code, so they get their on file
configure(allmodules) {
    apply from: "$rootDir/generators.gradle"
}

minecraft { }

// find a file in all the passed roots
def findFiles(FileCollection roots, String path) {
    return roots.collect { file(it.path + path) }.findAll { it.exists() }
}

// merge the contents of all the modules' `build/classes` directories into root project's `build/merged/classes` directory
task mergeClasses(type: Sync) {
    productionModules.each { mod ->
        from(mod.sourceSets.main.output.classesDirs) {
            // exclude some of the generated files
            exclude '**/LibModuleSkeleton.class'
            exclude 'MixinConnector.class'
        }
    }
    into(file("$buildDir/merged/classes"))
}

// merge the contents of all the modules' `build/resources` directories into root project's `build/merged/resources` directory
task mergeResources(type: Sync) {
    ext.outputDir = file("$buildDir/merged/resources")

    productionModules.each { mod ->
        from(mod.sourceSets.main.output.resourcesDir) {
            if (mod.path == ":core") {
                // the core module generates an `index.txt` that stores a list of modules to load at runtime. This list
                // includes development_only mods, so we have to strip those out first
                filesMatching('META-INF/modules/index.txt') {
                    filter { line ->
                        if (project(":$line").findProperty("development_only") == "true")
                            return null
                        return line
                    }
                }
            } else {
                // these are all either generated for the dev environment or data files that are used to generate files
                // in the post-processing step
                exclude 'META-INF/coremods.json'
                exclude 'META-INF/mods.toml'
                exclude 'META-INF/dependencies.toml'
                exclude 'META-INF/mixins.txt'
            }
        }
    }
    into(outputDir)

    doLast { // do final post-processing to merge the mods
        ext.outputDir = file("$buildDir/merged/resources")

        def resources = files([])
        productionModules.each { resources.from(it.sourceSets.main.resources.sourceDirectories) }

        file("$outputDir/META-INF").mkdirs()

        // merge the coremods.json files
        def coremodsJson = file("$outputDir/META-INF/coremods.json")
        def allCoremods = findFiles(resources, "/META-INF/coremods.json")

        coremodsJson.text =
                "{\n" + allCoremods.collect {
                    it.text
                            .replaceAll("[{}]", "") // replace enclosing brackets with blank lines
                            .replaceAll("\\s+\$", "") // remove trailing whitespace
                            .split("\n").findAll { !it.matches("^\\s*\$") } // remove blank lines
                            .join("\n") // re-join lines
                }.join(",\n") + "\n}"

        // add additional external dependencies to main mods.toml
        def additionalDependencies = resources
                .collect { file(it.path + "/META-INF/dependencies.toml") }.findAll { it.exists() }
                .collect {
                    it.text
                            .replaceAll("MOD_ID", "librarianlib")
                            .replaceAll("\\s+\$", "")
                }.join("\n")
        def modsToml = file("$outputDir/META-INF/mods.toml")
        modsToml.text = modsToml.text + additionalDependencies
    }
}

jar {
    configurations.shade.each { dep ->
        from(zipTree(dep)) {
            exclude 'META-INF', 'META-INF/**'
        }
    }
    // include the merged classes and resources
    from(mergeClasses)
    from(mergeResources)

    productionModules.each { module ->
        from(file("$module.compileJava.refMapFile.parent/$module.compileJava.refMap"))
    }
}

// set up the output jar for each of the production modules
configure(productionModules + [project]) {
    def manifestAttributes = project == rootProject ?
            [
                    "Implementation-Title": "LibrarianLib",
                    "Implementation-Version": "$mod_version",
                    "Implementation-Vendor" :"Team Wizardry",
                    "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                    // Specify the IMixinConnector. This class is present at runtime, but the runtime manifest
                    // specifies a different mixin container with only the mixin files from that specific module.
                    // https://github.com/SpongePowered/Mixin/wiki/Release-Notes---Mixin-0.8#toolchain-and-environment-changes
                    "MixinConnector": "com.teamwizardry.librarianlib.MixinConnector"
            ]
            :
            [
                    "Implementation-Title"    : "LibrarianLib $human_name",
                    "Implementation-Version"  : "$mod_version",
                    "Implementation-Vendor"   : "Team Wizardry",
                    "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                    // Specify the IMixinConnector. This contains only the mixin files from this specific module.
                    // https://github.com/SpongePowered/Mixin/wiki/Release-Notes---Mixin-0.8#toolchain-and-environment-changes
                    "MixinConnector": "MixinConnector"
            ]
    components.java

    def reobfArtifact = artifacts.add('archives', file("$buildDir/reobfJar/output.jar")) {
        type 'jar'
        builtBy 'reobfJar'
    }

    jar {
        manifest.attributes(manifestAttributes)
    }
    task sourceJar(type: Jar) {
        from sourceSets.main.allSource
        from sourceSets.main.output.resourcesDir
        dependsOn processResources
        manifest.attributes(manifestAttributes)
    }
    task deobfJar(type: Jar) {
        from sourceSets.main.output
        dependsOn classes
        dependsOn processResources
        manifest.attributes(manifestAttributes)
    }

    // For some reason we need to apply the publish plugin at the last moment, otherwise there are odd issues with it
    // already being configured
    apply plugin: 'maven-publish'
    publishing {
        publications {
            mod(MavenPublication) {
                from components.java
                if(project != rootProject)
                    artifacts = [deobfJar]
                artifact sourceJar {
                    classifier "sources"
                }
                pom {
                    // `.toString()` immediately evaluates the `GString` to a `String`, which is apparently necessary
                    // for the maven-publish plugin
                    name = project == rootProject ? "LibrarianLib" : "LibrarianLib $human_name".toString()
                    description = project == rootProject ? "The final packaged LibrarianLib jar" : "$module_description".toString()
                    url = 'http://github.com/LibrarianLib/LibrarianLib'
                    licenses {
                        license {
                            name = 'GNU Lesser General Public License v3'
                            url = 'https://www.gnu.org/licenses/lgpl-3.0.txt'
                        }
                    }
                    scm {
                        connection = 'scm:git:https://github.com/LibrarianLib/LibrarianLib.git'
                        developerConnection = 'scm:git:ssh://github.com/LibrarianLib/LibrarianLib.git'
                        url = 'https://github.com/LibrarianLib/LibrarianLib'
                    }
                    // Remove the forge dependencies from the POM
                    withXml {
                        def node = asNode()
                        node.dependencies.'*'.findAll {
                            it.groupId.text() == 'net.minecraftforge'
                        }.each {
                            it.parent().remove(it)
                        }
                    }
                }
            }
        }
        repositories {
            maven {
                // change URLs to point to your repos, e.g. http://my.org/repo
                def releasesRepoUrl = "file://$buildDir/repos/releases"
                def snapshotsRepoUrl = "file://$buildDir/repos/snapshots"
                url = version.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
            }
        }
    }
}


task publishAllToMavenLocal {
    group = 'Publishing'
    productionModules.each {
        dependsOn it.publishToMavenLocal
    }
}

task publishAll {
    group = 'Publishing'
    productionModules.each {
        dependsOn it.publish
    }
}
