package com.teamwizardry.librarianlib.features.gui.value

import com.teamwizardry.librarianlib.features.animator.AnimatableProperty
import com.teamwizardry.librarianlib.features.animator.Animation
import com.teamwizardry.librarianlib.features.animator.Easing
import com.teamwizardry.librarianlib.features.animator.Lerper
import com.teamwizardry.librarianlib.features.animator.LerperHandler
import java.util.function.Supplier

/**
 * Creates implicit animations for [IMValues][IMValue] and [RMValues][RMValue].
 *
 * For most situations, manually creating [BasicAnimations][BasicAnimation] is overkill, and certainly far too verbose.
 * GuiAnimator provides a method that receives a duration, easing, and callback. Every [IMValue] or [RMValue] that
 * changes inside of that callback will be added to the resulting animation, which can then be further modified
 * (e.g. to loop or reverse) before being added to an animator as you would any other animation.
 *
 *
 * ```java
 * BasicAnimation<YourComponent> animSize = new BasicAnimation<>(component, "size");
 * animSize.setDuration(5);
 * animSize.setEasing(Easing.easeOutCubic);
 * animSize.setRepeatCount(2);
 * animSize.setTo(targetSize);
 * component.add(animSize);
 *
 * BasicAnimation<YourComponent> animPos = new BasicAnimation<>(component, "pos");
 * animPos.setDuration(5);
 * animPos.setEasing(Easing.easeOutCubic);
 * animPos.setRepeatCount(2);
 * animPos.setTo(targetPos);
 * component.add(animPos);
 *
 * BasicAnimation<YourComponent> animRadius = new BasicAnimation<>(component, "radius");
 * animRadius.setDuration(5);
 * animRadius.setEasing(Easing.easeOutCubic);
 * animRadius.setRepeatCount(2);
 * animRadius.setTo(targetColor);
 * component.add(animRadius);
 * ```
 * ### vs.
 * ```java
 * GuiAnimation anim = GuiAnimator.animate(5, Easing.easeOutCubic, () -> {
 *     component.setSize(targetSize);
 *     component.setPos(targetPos);
 *     // the set____ and get____ are generated by kotlin and forward to the I/RMValue. Java code either has to
 *     // manually specify these methods or use the [IMValue.setValue] or [RMValue.set] methods
 *     component.radius.set(targetRadius);
 * });
 * anim.setRepeatCount(2);
 * component.add(anim);
 * ```
 */
class GuiAnimator {
    companion object {
        private val threadLocal = ThreadLocal<GuiAnimator>()

        @JvmStatic
        val current: GuiAnimator
            get() {
                return threadLocal.get() ?: GuiAnimator().also { threadLocal.set(it) }
            }

        fun animate(duration: Float, easing: Easing = Easing.linear, block: () -> Unit): Animation<*> {
            return current.animate(duration, easing, block)
        }
        fun animate(duration: Float, easing: Easing = Easing.linear, block: Runnable): Animation<*> {
            return current.animate(duration, easing, block)
        }
    }

    private val animations = mutableMapOf<GuiAnimatable, Any?>()
    private var isAnimating = false

    /**
     * Runs the passed block and creates an animation for each [IMValue] and [RMValue] that changes inside it.
     *
     * The first time a given [IMValue] or [RMValue] is modified inside of [block] the value is saved. This will be
     * used as the start of the animation.
     * After the block finishes each I/RMValue that is going to be included in the animation has its value read.
     * These values will be used as the ends of each animation.
     * If the start and end values are equal or either is null no animations will be added for that I/RMValue.
     */
    @JvmOverloads
    fun animate(duration: Float, easing: Easing = Easing.linear, block: Runnable): Animation<*> {
        animations.clear()
        isAnimating = true

        block.run()

        val valueAnimations = animations.mapNotNull {
            val start = it.value
            val end = it.key.getAnimatableValue()
            if(end == null || start == null || start == end)
                return@mapNotNull null

            GuiImplicitAnimation.ValueAnimation(it.key, start, end)
        }
        val anim = GuiImplicitAnimation(valueAnimations)
        anim.duration = duration
        anim.easing = easing

        isAnimating = false
        animations.clear()

        return anim
    }

    /**
     * @see animate
     */
    fun animate(duration: Float, easing: Easing = Easing.linear, block: () -> Unit): Animation<*> {
        return this.animate(duration, easing, Runnable(block))
    }

    /**
     * Registers the given animatable to be included in the animation. See [animate] for details
     */
    fun add(target: GuiAnimatable) {
        if(!isAnimating) return
        animations.getOrPut(target) { target.getAnimatableValue() }
    }
}

@Suppress("UNCHECKED_CAST")
private class GuiImplicitAnimation(val targets: List<ValueAnimation>): Animation<Any>(
    PointlessAnimatableObject,
    AnimatableProperty.get(PointlessAnimatableObject::class.java, "field") as AnimatableProperty<Any>) {
    var easing: Easing = Easing.linear

    override fun update(time: Float) {
        val progress = easing(timeFraction(time))
        targets.forEach { it.update(progress) }
    }

    override fun complete() {
        targets.forEach { it.complete() }
        super.complete()
    }

    object PointlessAnimatableObject {
        var field = 0
    }

    class ValueAnimation(val target: GuiAnimatable, val start: Any, val end: Any) {
        private var lerper: Lerper<Any>
        init {
            var clazz: Class<*> = Any::class.java

            if(start.javaClass == end.javaClass) {
                clazz = start.javaClass
            } else {
                val startClasses = mutableSetOf<Class<*>>()
                var currentClass: Class<*>? = start.javaClass
                while (currentClass != null) {
                    startClasses.add(currentClass)
                    currentClass = currentClass.superclass
                }

                currentClass = end.javaClass
                while (currentClass != null) {
                    if (currentClass in startClasses) {
                        clazz = currentClass
                        break
                    }
                    currentClass = currentClass.superclass
                }
            }
            lerper = LerperHandler.getLerperOrError(clazz) as Lerper<Any>
        }

        var previousValue: Any? = null
        var previousCallback: Any? = null

        fun update(progress: Float) {
            val newValue = lerper.lerp(start, end, progress)

            val currentValue = target.getAnimatableValue()
            if(currentValue != previousValue) { // the value was manually set
                previousCallback = null
            }
            previousValue = currentValue
            val currentCallback = target.getAnimatableCallback()
            if(currentCallback != null && currentCallback != previousCallback) {
                previousCallback = currentCallback
            }
            target.setAnimatableValue(newValue)
        }

        fun complete() {
            previousCallback?.let { target.setAnimatableCallback(it) }
        }
    }
}

interface GuiAnimatable {
    fun getAnimatableValue(): Any?
    fun setAnimatableValue(value: Any?)
    fun getAnimatableCallback(): Any?
    fun setAnimatableCallback(supplier: Any)
}